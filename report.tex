\documentclass[a4paper,12pt,titlepage,finall]{article}

\usepackage[T1,T2A]{fontenc}     % форматы шрифтов
\usepackage[utf8x]{inputenc}     % кодировка символов, используемая в данном файле
\usepackage[russian]{babel}      % пакет русификации
\usepackage{tikz}                % для создания иллюстраций
\usepackage{pgfplots}            % для вывода графиков функций
\usepackage{geometry}		 % для настройки размера полей
\usepackage{indentfirst}         % для отступа в первом абзаце секции
\usepackage{multirow}            % для таблицы с результатами
\usepackage{amssymb}            % для математических символов
\usepackage{amsmath}            % для математических символов
\usepackage{xfrac}                  % для математических символов
\usepackage{pgfplots}	      % пакет графиков
\usepackage{caption}               % для таблиц без нумерации

\pgfplotsset{compat=1.9}
\usetikzlibrary{spy}

% выбираем размер листа А4, все поля ставим по 3см
\geometry{a4paper,left=30mm,top=30mm,bottom=30mm,right=30mm}

\setcounter{secnumdepth}{0}      % отключаем нумерацию секций

\usepgfplotslibrary{fillbetween} % для изображения областей на графиках


\begin{document}
% Титульный лист
\begin{titlepage}
    \begin{center}
	{\small \sc Московский государственный университет \\имени М.~В.~Ломоносова\\
	Факультет вычислительной математики и кибернетики\\}
	\vfill
	{\Large \sc Отчет по заданию №1}\\
	~\\
	{\large \bf <<Методы сортировки>>}\\ 
	~\\
	{\large \bf Вариант 1 / 3 / 3 / 5}
    \end{center}
    \begin{flushright}
	\vfill {Выполнил:\\
	студент 102 группы\\
	Грознецкий~А.~Е.\\
	~\\
	Преподаватель:\\
	Смирнов~Л.~В.}
    \end{flushright}
    \begin{center}
	\vfill
	{\small Москва\\2023}
    \end{center}
\end{titlepage}

% Автоматически генерируем оглавление на отдельной странице
\tableofcontents
\newpage

\section{Постановка задачи}

\subsection{Введение}

Была поставлена задача реализовать два метода сортировки массива и провести их экспериментальное сравнение. Элементами массива являются целые числа типа \textbf{\textit{int}},  т.~е.  целые знаковые 32-битные числа. Упорядочивание чисел должно происходить \textbf{\textit{по неубыванию модулей}} (без учета знака). Для сравенения были выбраны сортировки: \textbf{\textit{методом Шелла}} и \textbf{\textit{пирамидальная сортировка}}.

\subsection{Массивы чисел}

Для каждого из реализуемых методов сортировки необходимо предусмотреть возможность работы с массивами длины от $1$ до $N$ ($N \geqslant 1$). Память для хранения массива чисел следует выделять \textit{динамически}.

\subsection{Экспериментальное сравнение}

Экспериментальное сравнение методов сортировок заключается в сопоставлении \textbf{числа сравнений} элементов и \textbf{числа перестановок} элементов. Важным условием сравнения является сравнение на одинаковых исходных массивах, при этом следует рассмотреть массивы разной длины: $n = 10, 100, 1000, 10000$. Тестирование сортировок должно производиться на различных типах исходных данных:

\begin{itemize}

    \item элементы уже упорядочены (1);
    \item элементы упорядочены в обратном порядке (2);
    \item расстановка элементов случайна (3, 4).

\end{itemize}

Результаты экспериментов должны быть оформлены на основе нескольких запусков программы, их необходимо оформить в виде таблицы.


\newpage

\section{Результаты экспериментов}

\subsection{Сортировка методом Шелла}

\subsubsection*{Описание метода} 

Сортировка  \textbf{методом Шелла} является усовершенствованным вариантом \textit{сортировки вставками}, где в массиве чисел индуктивно рассматривается \textit{подмассив} с фиксированным левым краем (упорядоченный на предыдущем шаге индукции), к которому добавляется \textit{следующий элемент}, место которого однозначно опрделяется за линейное (от длины подмассива) число сравнений. Таким образом, для каждого подмассива длины от $1$ до $N$ — длины самого массива — выполняется линейное число сравнений, и итоговая сложность является \textit{квадратичной}.

\par
Усовершенстовавание сортирвки вставками (то есть метод Шелла) состоит в том, что сравнение происходит не только рядом стоящих элементов, но и элементов, удаленных на определенное расстояние $d$. Это позволяет \textit{грубо просеять} массив для более эффективного применения сортировки вставками в финале. 
\par

В классическом методе Шелла для массива длины $N$ происходит $\lfloor \log_{2}{N} \rfloor$  \textit{просеиваний}, для каждого из которых расстояние $d$ определяется как: 

\begin{equation}\label{d_i_extended}
d_i = \lfloor \frac{N}{2^i} \rfloor
\end{equation}

Таким образом, на $i$-м \textit{просеивании} происходит лишь сортировка вставками всех подмассивов, в которых элементы отстоят друг от друга на расстоянии $d_i$.

\subsubsection*{Теоретическая оценка} 

Проведем теоретическую оценку количества сравнений при сортировке \textit{методом Шелла}. Для удобства подсчёта примем $N = 2 ^ m$. В таком случае выражение \eqref{d_i_extended} примет вид:

\begin{equation}\label{d_i}
d_i = \lfloor \frac{N}{2^i} \rfloor = 2^{m-i}
\end{equation}

Тогда для начала посчитаем число сравнений $k_i$, соответствующее $i$-му \textit{просеиванию}. Не трудно заметить, что для элементов массива с $1$ по $d_i$ нет элемента, который отстоит от них на расстоянии $d_i$, значит для них не будет происходит сравнений с левостоящими элементами. Для элементов с $d_i+1$ по $2 d_i$ есть лишь один элемент на расстоянии, кратном $d_i$, а следовательно для них возможно (и реализуется в худшем слуаче) одно сравнение. Аналогично рассуждая для всех элементов, получим выражение для значения $k_i$ в худшем случае:

$$k_i = 0d_i + 1d_i + 2d_i + 3d_i + \dots + (2^i - 1)d_i = d_i  \displaystyle\sum_{j=0}^{2^i - 1} j = d_i  \frac{2^i (2^i - 1) }{2}$$
То есть:
\begin{equation}\label{k_i}
k_i = d_i2^{i-1} (2^i - 1)
\end{equation}

Подставляя в выражение \eqref{k_i} полученное ранее выражение \eqref{d_i}, получим:

$$k_i = 2^{m-i} 2^{i-1} (2^i - 1) = 2^{m-1} (2^i - 1)$$

Тогда результирующее число сравнений $\overline{C} (N)$ \textit{в худшем случае} будет суммой числа сравнений по всем $\lfloor \log_{2}{N} \rfloor = m$ \textit{просеиваниям}:

\begin{eqnarray*}
\overline{C} (N) = \displaystyle\sum_{i=1}^{m}k_i = \displaystyle\sum_{i=1}^{m} 2^{m-1} (2^i - 1) = 2^{m-1} \displaystyle\sum_{i=1}^{m} (2^i - 1) = \\
= 2^{m-1} (\displaystyle\sum_{i=1}^{m} 2^i   - \displaystyle\sum_{i=1}^{m}1) = 2^{m-1} ((2^m-1) \cdot2 - m) =\\
= 2^m (2^m-1 - \frac{m}{2}) = N (N - 1 - \frac{\log_{2}{N}}{2}) = O(N^2)
\end{eqnarray*}

Таким образом, верхняя граница сложности сортировки \textbf{методом Шелла} в классическом случае геометрической прогрессии — $O(N^2)$. 

\par

Подсчет числа сравнений в лучшем случае (массив уже отсортирован) проведем так же для $N = 2 ^ m$. Отличаться будут лишь выражения для  $k_i$, так как для оставновки очередного \textit{просеивания} будет достаточно одного сравнения. Имеем:

\begin{equation}\label{k_i_best}
k_i = d_i (2^i - 1) = 2^{m-i}(2^i - 1)
\end{equation}

Получим нижнюю границу числа сравнений $\underline{C} (N)$:

\begin{eqnarray*}
\underline{C} (N) = \displaystyle\sum_{i=1}^{m}k_i = \displaystyle\sum_{i=1}^{m}  2^{m-i}(2^i - 1) = 2^m  \displaystyle\sum_{i=1}^{m} \frac{2^i - 1}{2^i} = \\
=  2^m  \displaystyle\sum_{i=1}^{m} (1 - \frac{1}{2^i}) =  2^m ( \displaystyle\sum_{i=1}^{m} 1 -\displaystyle\sum_{i=1}^{m} \frac{1}{2^i}) ) = 2^m ( m - (1 - \frac{1}{2^m}) ) = \\
= 2^m ( m - 1 + \frac{1}{2^m} ) = N (\log_{2}{N} - 1 + \frac{1}{N}) = O(N \log{N})
\end{eqnarray*}

Таким образом, в лучшем случае сложность сортировки \textbf{методом Шелла} для интервалов, образующих геометрическую прогрессию, — $O(N \log{N})$. 

\subsubsection*{Экспериментальная оценка} 

В экспериментальной оценке попытаемся выявить среднюю сложность сортировки \textbf{методом Шелла} и сравнить ее с тереотичесими нижней и верхней границами, а также сравнить нижние и верхние теоретические границы с экспериментальными.

\par

Для начала сравним теоретические и экспериментальные оценки верхней и нижней границ, для этого проведем серию запсуков программы сортировки на различных исходных данных и массивах различной длины и отобразим результаты в таблице \ref{shell_table} (средние значения округляются вниз).

\begin{table}[h]
\centering
\caption{Результаты работы сортировки методом Шелла}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{\textbf{N}} & \multirow{2}{*}{\textbf{Параметр}} & \multicolumn{4}{|c|}{\textbf{Номер сгенерированного массива}} & \textbf{Среднее} \\
    \cline{3-6}
    & & \parbox{1.5cm}{\centering 1} & \parbox{1.5cm}{\centering 2} & \parbox{1.5cm}{\centering 3} & \parbox{1.5cm}{\centering 4} & \textbf{значение} \\
    \hline
    \multirow{2}{*}{10} & Сравнения & 22 & 27 & 28 & 27& 26 \\
    \cline{2-7}
                        & Перемещения & 0 & 13 & 7 & 11 & 7\\
    \hline
    \multirow{2}{*}{100} & Сравнения & 503  & 668 & 904 & 851 & 731\\
    \cline{2-7}
                         & Перемещения & 0 & 260 & 450 & 400 & 277\\
    \hline
    \multirow{2}{*}{1000} & Сравнения & 8006 & 11716  & 15877 & 15065 & 12666\\
    \cline{2-7}
                          & Перемещения & 0 & 4700 & 8372 & 7584 & 5164\\
    \hline
    \multirow{2}{*}{10000} & Сравнения & 120005 & 172578 & 258153 & 268041 & 204694\\
    \cline{2-7}
                           & Перемещения & 0 & 62560 & 143232 & 153063 & 89713\\
    \hline
\end{tabular}
\label{shell_table}
\end{table}

Изобразим \textit{числа сравнений} из таблицы \ref{shell_table} на графике: средние значения $C_a (N)$ (столбец \textit{среднее значение}), значения уже упорядоченного массива $C_b (N)$ (столбец~1) и значения обратно упорядоченного массива $C_w (N)$ (столбец~2), а также теоретические верхнюю и нижнюю границы, т.~е. функции $\overline{C} (N)$ и $\underline{C} (N)$.\\


\begin{tikzpicture}[spy using outlines=
	{circle, magnification=10, connect spies}]
\begin{axis}[
	legend pos = north east, 
	title = Shell sort experiment results,
	width = 300, height = 200,
	domain = 0:10000,
	xmin = 0, 
	xmax = 10000,
	ymin = 0,
	ymax = 1500000,
	xlabel = {$N$},
	ylabel = {$count~of~operations$},
	minor tick num = 2,
        grid = major
]
\legend{ 
	$\overline{C} (N)$ — upper bound,
	$\underline{C} (N)$ — lower bound, 
	$C_a (N)$ — average case,
	$C_b (N)$ — best case,
	$C_w (N)$ — worth case,
};

\addplot[blue] {x*(x-1-0.5*log2(x))};
\addplot[green] {x*(log2(x) - 1 + 1/x)};
\addplot[red] table {
	x        y
       10      26
      100     731
     1000   12666
    10000  204694
};

\addplot[yellow] table {
       x          y
      10        22
      100     503
     1000   8006
    10000  120005
};

\addplot[violet] table {
       x          y
      10        27
      100     668
     1000   11716
    10000  172578
};

\coordinate (spypoint) at (axis cs:8500,137005);
\coordinate (magnifyglass) at (axis cs:13000,900000);

\end{axis}

\spy [black, size=4.0cm] on (spypoint)
   in node[fill=white] at (magnifyglass);

\end{tikzpicture}


Какие выводы можно сделать:

\begin{enumerate}
\item
Не трудно видеть, что $C_a (N)$ лежит между $\underline{C} (N)$ и $\overline{C} (N)$, что и ожидалось. 

\item
Также видно, что $C_b (N)$ лежит ниже теоретической границы $\underline{C} (N)$. Объясняется это тем, что при подсчете теоретической нижней границы рассматривался случай числа элементов массива $N = 2^m$ и как видно из формулы \eqref{k_i} реальное число сравнений должно быть меньше, так как в результирующей сумме каждое $d_i$ будет округлено вниз — формула \eqref{d_i_extended}.

\item 
Кажется странным, что $C_w (N)$ — \textit{worth case} — лежит ниже среднего значения $C_a (N)$, но дело в том, что обратно упорядоченный массив не является тем самым \textit{worth case} для сортировки \textbf{методом Шелла}. Худшим случаем для алгоритма \textit{Shell sort} является массив, в котором на каждом \textit{просеивании} будут возникать независимые подмассивы, изменение порядка элементов в которых \textit{не улучшает ситуации}. То есть массив вида: $a_1, a_{\frac{n}{2}}, a_2, a_{\frac{n}{2} + 1}, a_3, a_{\frac{n}{2}+2}, \dots, a_{\frac{n}{2}-1}, a_n$ — применение к такому массиву  \textit{просеиваний} с шагом $d_i$ отличным от 1 не изменяет его, поэтому худший случай достигается при орагнизации массива таким образом, что каждый из подмассивов (четный и нечетный) обладают свойствами исходного массива. Здесь подразумевается, что $a_1, a_2, a_3, \dots, a_n$ — упорядочен.
\end{enumerate}


Для дальнейшего сравнения алгоритмов \textit{Shell sort} и \textit{Heap sort} построим график функции $K(N) = C(N) + S(N)$ — суммарного числа операций: \textit{сравнения} $C(N)$ и \textit{перестановки} $S(N)$. Результаты запусков \textit{Shell sort} на \textit{рандомных} массивах \textbf{большей длины} отображены в таблице \ref{shell_table_approximation}.\\

\begin{table}[h]
\centering
\caption{Экспериментальные данные сортировки методом Шелла}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
     $N$ & 10000 & 50000 & 100000 & 250000 & 500000 & 750000 & $\cdots$ \\
    \hline
     $C(N)$ & 267459 & 1899020 & 4256522  & 12236202 & 27610867 & 45237571 & $\cdots$ \\
    \hline
    $S(N)$ & 152527 & 1224551 & 2806907  & 8363321 & 19363502 & 32121299 & $\cdots$ \\
    \hline
    $K(N)$ & 419986 & 3123571 & 7063429  & 20599523 & 46974369 & 77358870 & $\cdots$ \\
    \hline
\end{tabular}
\caption*{}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    $\cdots$ & 1000000 & 1250000 & 2500000 & 5000000 & 7500000 & 10000000\\
    \hline
     $\cdots$ & 66656167 & 80010998 & 185038268  & 418826708 & 649556120 & 977036440 \\
    \hline
    $\cdots$ & 49157989 & 56898655 & 136300443  & 316338734 & 495849092 & 762049747 \\
    \hline
    $\cdots$ & 115814156 & 136909653 & 321338711  & 735165442 & 1145405212 & 1739086187 \\
    \hline
\end{tabular}
\label{shell_table_approximation}
\end{table}

На основе данных из таблицы \ref{shell_table_approximation} построим график зависимости \textit{общего числа операций} в алгоритме сортировки \textbf{методом Шелла} от \textit{длины массивы}, к которому обратимся позже:\\

\begin{tikzpicture}
\begin{axis}[
	legend pos = north west, 
	title = Shell sort approximation,
	width = 350, height = 200,
	domain = 0:10000000,
	xmin = 0, 
	xmax = 10000000,
	ymin = 0,
	ymax = 2000000000,
	xlabel = {$N$},
	ylabel = {$count~of~operations$},
	minor tick num = 2,
        grid = major
]

\addplot[red] table {
	x 			y
	10000		419986
	50000		3123571
	100000		7063429
	250000		20599523
	500000		46974369
	750000		77358870
	1000000		115814156
	1250000		136909653
	2500000		321338711
	5000000		735165442
	7500000		1145405212
	10000000		1739086187
};

\legend{ 
	$K(N)$ — count of compares and swaps,
};

\end{axis}
\end{tikzpicture}


\subsection{Пирамидальная сортировка}

\subsubsection*{Описание метода} 

\textbf{Пирамидальная сортировка} — это метод сортировки, основанный на такой структуре данных, как бинарная куча, благодаря устройству которой, возможно получить наибольший (наименьший) элемент в убывающей (возрастаюшей) куче за $O(1)$. Сам же алгоритм можно разделить на два этапа:
\begin{enumerate}
\item
Итеративное построение кучи из исходного массива.

\item
Итеративное извлечение максимального элемента из кучи и его добавление в конец массива.
\end{enumerate}

Причем реализация кучи возможна в самом массиве данных, благодаря чему алгоритм \textit{Heap sort} не требует дополнительной памяти (требует~$O(1)$). 

\subsubsection*{Теоретическая оценка} 

Оценку сложности алгоритма можно разбить на две оценки его независимых частей: оценка сложности алгоритма \textit{построения пирамиды} и оценка сложности \textit{извлечения элементов из готовой пирамиды}. Начнем с первого: как уже было отмечено, построение пирамиды — итеративный процесс, поэтому проведем подсчёт числа сравнений на отдельной итерации, то есть при добавлении $i$-го элемента к куче размера~$i-1$, нетрудно понять, что это требует $\log_{2}{i}$ сравнений в худшем случае. Воспользуемся ранее ввёденными при подсчёте алгоритмической сложности сортировки \textit{Shell sort} обозначениями и запишем число сравнений на  $i$-й итерации:

\begin{equation}\label{heap_k_i}
k_i = \log_{2}{i}
\end{equation}

Тогда результирующее число сравнений для создания пирамиды это:

\begin{equation}\label{k1_heap}
C_1(N) = \displaystyle\sum_{i=1}^{N} k_i = \displaystyle\sum_{i=1}^{N} \log_{2}{i} = \log_{2}{\prod\limits_{i = 1}^N i} = \log_{2}{N!}
\end{equation}

Не трудно заметить, что \textit{число сравнений} элементов массива второго этапа $C_2(N) = C_1(N)$, так как происходит суммирование тех же самых величин, но лишь в другом порядке, что не меняет результата. Поэтому результирующая сложность пирамидальной сортировки есть $C(N) = C_1(N) + C_2(N) = 2\log_{2}{N!}$
\\

Далее, для того чтобы привести выражение $C(N) = 2\log_{2}{N!}$ к более знакомому виду, воспользуемся \textbf{формулой Муавра~—~Стирлинга} приближенного вычисления гамма-функции:

\begin{equation}\label{Muavr_1}
\displaystyle \ln \Gamma (N+1)=\ln N!=N\ln N-n+O(\ln N)
\end{equation}

Получим:

\begin{equation}\label{Heap_result_K}
C(N) = 2\log_{2}{N!} = \frac{2}{\ln{2}}\ln{N!} = \frac{2}{\ln{2}}( N\ln N-N+O(\ln N)) = O(N\log N)
\end{equation}

Таким образом, алгоритм \textbf{пирамидальной сортировки} имеет \textit{квазилинейную} сложность: $O(N\log N)$.

\subsubsection*{Экспериментальная оценка} 

В экспериментальной оценке получим среднюю сложность \textbf{пирамидальной сортировки} и сравним её с теоретической. Для этого проведем серию запсуков программы сортировки на различных исходных данных и отобразим результаты в таблице \ref{heap_table} (средние значения округляются вниз). Здесь важно отметить, что запуски происходят на тех же самых массивах, что и \textit{Shell sort} (о том, как это было реализовано подробно рассказано в соотетствующем разделе \textit{спецификация функций}).

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{\textbf{N}} & \multirow{2}{*}{\textbf{Параметр}} & \multicolumn{4}{|c|}{\textbf{Номер сгенерированного массива}} & \textbf{Среднее} \\
    \cline{3-6}
    & & \parbox{1.5cm}{\centering 1} & \parbox{1.5cm}{\centering 2} & \parbox{1.5cm}{\centering 3} & \parbox{1.5cm}{\centering 4} & \textbf{значение} \\
    \hline
    \multirow{2}{*}{10} & Сравнения & 41 & 35 & 38 & 38&38 \\
    \cline{2-7}
                        & Перемещения & 31 & 22 & 30 & 28 & 27 \\
    \hline
    \multirow{2}{*}{100} & Сравнения & 1081  & 944 & 1031 & 1023 & 1019 \\
    \cline{2-7}
                         & Перемещения & 641 & 517 & 579 & 583 &580 \\
    \hline
    \multirow{2}{*}{1000} & Сравнения & 17583 & 15965 & 16863 & 16834 & 16811\\
    \cline{2-7}
                          & Перемещения & 9709 & 8317 & 9101 & 9087 & 9053\\
    \hline
    \multirow{2}{*}{10000} & Сравнения & 244460 & 226682 & 235458 & 235256 & 235464 \\
    \cline{2-7}
                           & Перемещения & 131957 & 116697 & 124285 & 124083 & 124255\\
    \hline
\end{tabular}
\caption{Результаты работы пирамидальной сортировки}
\label{heap_table}
\end{table}



Для построения графика функции $C(N)$ упростим выражение \eqref{Heap_result_K}. В формуле \eqref{Muavr_1} следующий член в разложении $O(\ln{n})$ — это $\frac{1}{2}\ln{(2\pi n)}$ и формулу \eqref{Muavr_1} можно записать в эквивалентной форме:

\begin{equation}\label{Muavr_2}
\displaystyle N!\sim {\sqrt {2\pi N}}\left({\frac {N}{e}}\right)^{N}
\end{equation}


Для изображения графика функции $C(N)$ будем пользоваться этой формулой, так как она не дискретна, и уже поддерживается встроенным пакетом изображения графиков (в отличие от тоже не дискретной гамма-функции).

\begin{eqnarray*}\label{heap_sort_K_Muavr_graph_extended}
C(N) =  \frac{2}{\ln{2}}\ln{N!} \sim \frac{2}{\ln{2}}\ln{\left( {\sqrt {2\pi n}}\left({\frac {N}{e}}\right)^{N}\right)} = \frac{2N}{\ln{2}}\ln{\left( {\frac {N}{e}} {\left({2\pi N}\right)^{\frac{1}{2N}}}\right)} \sim \\
\sim \frac{2N}{\ln{2}}\ln{\left( {\frac {N}{e}} {N^{\frac{1}{2N}}}\right)} = \frac{2N}{\ln{2}}\ln{\left( {\frac {N^{\frac{2N + 1}{2N}}}{e}}\right)} \sim \frac{2N}{\ln{2}}\ln{\frac{N}{e}} = 2N \log_{2}{\frac{N}{e}}
\end{eqnarray*}\\

Получим окончательно:

\begin{equation}\label{heap_sort_K_Muavr_graph}
C(N) = 2N \log_{2}{\frac{N}{e}}
\end{equation}


Теперь можем изобразить \textit{числа сравнений} из таблицы \ref{heap_table} на графике: средние значения $C_a (N)$ (столбец \textit{среднее значение}), значения уже упорядоченного массива $C_b (N)$ (столбец~1) и значения обратно упорядоченного массива $C_w (N)$ (столбец~2), а также график теоретической сложности \textit{пирамидальной сортировки} $C(N)$.
\\

\begin{tikzpicture}[spy using outlines=
	{circle, magnification=8, connect spies}]
\begin{axis}[
	legend pos = north west, 
	title = Heap sort experiment results,
	width = 300, height = 200,
	domain = 0:10000,
	xmin = 0, 
	xmax = 10000,
	ymin = 0,
	ymax = 250000,
	xlabel = {$N$},
	ylabel = {$count~of~operations$},
	minor tick num = 2,
        grid = major
]
\addplot[green] {2*x*log2(x/2.718)};

\addplot[red] table {
	x        y
       10      38
      100     1019
     1000   16811
    10000  235464
};

\addplot[yellow] table {
       x          y
      10        41
      100     1081
     1000    17583
    10000  244460
};

\addplot[violet] table {
       x          y
      10        35
      100     944
     1000   15965
    10000  226682
};

\legend{ 
	$C(N)$,
	$C_a(N)$,
	$C_b(N)$,
	$C_w(N)$,
};

\coordinate (spypoint) at (axis cs:9500,223500);
\coordinate (magnifyglass) at (axis cs:13000,90000);

\end{axis}

\spy [black, size=4.0cm] on (spypoint)
   in node[fill=white] at (magnifyglass);

\end{tikzpicture}
\\

Какие выводы можно сделать:
\begin{enumerate}
\item
Аналогично \textit{Shell sort} в \textit{Heap sort} можно заметить, что \textit{worth case} не является \textit{худшим}, и как бы это ни было странно, \textit{worth case} даже лучше \textit{best case}. Все потому, что в \textit{Heap sort} первым шагом создается пирамида, для которой уже упорядоченный массив является худшим случаем, в отличие от обратно упорядоченного, где с добавлением последнего элемента происходит его \textit{подъем} на самый верх.

\item
Также стоит отметить, что средняя число сравнений $C_a(N)$ довольно точно совпадает с теоретическим $С(N)$.
\end{enumerate}

Далее, для сравнения алгоритмов \textit{Shell sort} и \textit{Heap sort} построим график зависимости \textit{числа сравнений} в алгоритме \textbf{пирамидальной сортировки} от длины массивы, пробегающей \textbf{больший диапазон значений} — аналогично \textit{Shell sort}. Результаты запусков программы на \textit{сгенерированных случайным образом} массивах отображены в таблице \ref{heap_table_approximation}.\\

\begin{table}[h]
\centering
\caption{Экспериментальные данные сортировки методом Шелла}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
     $N$ & 10000 & 50000 & 100000 & 250000 & 500000 & 750000 & $\cdots$ \\
    \hline
     $C(N)$ & 235331 & 1409597 & 3019675  & 8198049 & 17396712 & 27007867 & $\cdots$ \\
    \hline
    $S(N)$ & 124224 & 737333 & 1574994  & 4261890 & 9023743 & 13992818 & $\cdots$ \\
    \hline
    $K(N)$ & 359555 & 2146930 & 4594669  & 12459939 & 26420455 & 41000685 & $\cdots$ \\
    \hline
\end{tabular}
\label{heap_table_approximation}
\end{table}

\begin{table}[h]
\begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    $\cdots$ & 1000000 & 1250000 & 2500000 & 5000000 & 7500000 & 10000000\\
    \hline
     $\cdots$ & 36794039 & 46829302 & 98659720  & 207320663 & 319711305 & 434644541 \\
    \hline
    $\cdots$ & 19048032 & 24228898 & 50957404  & 106916725 & 164739927 & 223835869 \\
    \hline
    $\cdots$ & 55842071 & 71058200 & 149617124  & 314237388 & 484451232 & 658480410 \\
    \hline
\end{tabular}
\end{table}

На основе данных из таблицы \ref{heap_table_approximation} построим график зависимости \textit{общего числа операций} в алгоритме \textbf{пирамидальной сортировки} от длины массивы, которым воспользуемся уже в следующем разделе:\\

\begin{tikzpicture}
\begin{axis}[
	legend pos = north west, 
	title = Heap sort approximation,
	width = 350, height = 200,
	domain = 0:10000000,
	xmin = 0, 
	xmax = 10000000,
	ymin = 0,
	ymax = 1000000000,
	xlabel = {$N$},
	ylabel = {$count~of~operations$},
	minor tick num = 2,
        grid = major
]

\addplot[green] table {
	x			y
    	10000		359555
	50000		2146930
	100000		4594669
	250000		12459939
	500000		26420455
	750000		41000685
	1000000		55842071
	1250000		71058200
	2500000		149617124
	5000000		314237388
	7500000		484451232
	10000000		658480410
};

\legend{ 
	$K(N)$ — count of compares and swaps,
};

\end{axis}
\end{tikzpicture}

\subsection{Сравнение алгоритмов \textit{Shell sort} и \textit{Heap sort}}

Рассмотрим полученные данные и проанализируем их отношения. Для начала изобразим общее число операций  \textit{Shell sort} и \textit{Heap sort} при $N = 10, 100, 1000, 10000$. \\

\begin{tikzpicture}
\begin{axis}[
	legend pos = north west, 
	title = Comparing \textit{Shell sort} and \textit{Heap sort} on small data,
	width = 370, height = 200,
	domain = 0:10000,
	xmin = 0, 
	xmax = 10000,
	ymin = 0,
	ymax = 400000,
	xlabel = {$N$},
	ylabel = {$count~of~operations$},
	minor tick num = 2,
        grid = major
]

\addplot[red] table {
	x                    y
       10                  33
      100                1247
      1000             23343
     10000		 409719
};

\addplot[green] table {
	x                    y
       10                  71
      100                1588
      1000             25882
     10000		 359541
};


\legend{ 
	$K(N)$ — Shell sort,
	$K(N)$ — Heap sort,
};

\end{axis}
\end{tikzpicture}
\\

Заметим, что сначала график, соответствующий \textit{Shell sort}, лежит ниже \textit{Heap sort} — из этого можем сделать вывод, что для небольших массивов есть смысл использовать \textit{Shell sort}. Но уже при достаточно больших $N$ происходит обратное. Для иллюстрации этого факта построим графики обшего числа операций $K(N)$ для $N$, пробегающего \textbf{больший диапазон значений}: \\


\begin{tikzpicture}
\begin{axis}[
	legend pos = north west, 
	title = Comparing \textit{Shell sort} and \textit{Heap sort} on big data,
	width = 370, height = 200,
	domain = 0:10000000,
	xmin = 0, 
	xmax = 10000000,
	ymin = 0,
	ymax = 1739086187,
	xlabel = {$N$},
	ylabel = {$count~of~operations$},
	minor tick num = 2,
        grid = major
]



\addplot[red] table {
	x 			y
	0			0
	10000		419986
	50000		3123571
	100000		7063429
	250000		20599523
	500000		46974369
	750000		77358870
	1000000		115814156
	1250000		136909653
	2500000		321338711
	5000000		735165442
	7500000		1145405212
	10000000		1739086187
};

\addplot[green] table {
	x			y
	0			0
    	10000		359555
	50000		2146930
	100000		4594669
	250000		12459939
	500000		26420455
	750000		41000685
	1000000		55842071
	1250000		71058200
	2500000		149617124
	5000000		314237388
	7500000		484451232
	10000000		658480410
};


\legend{ 
	$K(N)$ — Shell sort,
	$K(N)$ — Heap sort,
};

\end{axis}
\end{tikzpicture}
\par
При большем $N$ разница в числе операций становится существенной и \textit{Shell sort} проигрывает алгоритму \textit{Heap sort}. Как было написано выше, это происходит благодаря стабильной \textit{квазилинейной} сложности алгоритма \textit{Heap sort} — $O(N\log N)$ — что для алгоритма \textit{Shell sort} является лишь сложностью лучшего случая (когда массив уже отсортирован). 
\\

Попробуем выяснить более точные границы диапазона резонного примения алгоритма \textit{Shell sort}. Для этого приближенно найдем точку пересечения построенных графиков:\\

\begin{tikzpicture}[spy using outlines=
	{circle, magnification=8, connect spies}]
\begin{axis}[
	legend pos = south east, 
	title = Searching applicability bound,
	width = 370, height = 200,
	domain = 10:10000,
	xmin = 10, 
	xmax = 5000,
	ymin = 0,
	ymax = 200000,
	xlabel = {$N$},
	ylabel = {$count~of~operations$},
	minor tick num = 2,
        grid = minor
]


\addplot[red] table {
	x                    y
       10                  33
      100                1247
      1000             23343
     10000		 409719
};

\addplot[green] table {
	x                    y
       10                  71
      100                1588
      1000             25882
     10000		 359541
};

\legend{ 
	$K(N)$ — Shell sort,
	$K(N)$ — Heap sort,
};

\coordinate (spypoint) at (axis cs:1430,42800);
\coordinate (magnifyglass) at (axis cs:1000,120000);

\end{axis}

\spy [black, size=3.0cm] on (spypoint)
   in node[fill=white] at (magnifyglass);

\end{tikzpicture}
\par

Получим границу резонного примения алгоритма \textit{Shell sort}:  $N \approx 1500$. 

\subsubsection*{Вывод}
\begin{enumerate}
\item
Таким образом, алгоритм сортировки \textbf{методом Шелла} работает за меньшее число операций, чем алгоритм \textbf{пирамидальной сортировки} при $N \leqslant 1500$, а при больших $N$ меньшее число операций имеет алгоритм \textbf{пирамидальной сортировки}, что объясняется его стабильной квазилинейной сложностью.
\item
Откртым остаётся вопрос подсчёта \textit{теоретической} оценки средней сложности сортировки \textbf{методом Шелла} для интервалов, образующих геометрическую прогрессию $d_i = \frac{N}{2^i}$.
\end{enumerate}

\newpage


\section{Структура программы и спецификация функций}

Программу можно разделить на два логически независимых \textit{модуля}:
\begin{enumerate}
\item
Алгоритмы сортировки \textit{Shell sort} и \textit{Heap sort}.

\item
Функций, отвечющие за предостваление \textit{данных} алгоритмам сортировки и обработку их \textit{ответов}.
\end{enumerate}

\textbf{Первый модуль} включает в себя функции:

\begin{itemize}
\item
\texttt{void shell\_sort(int *a, int n)} — функция сортировки \textbf{методом Шелла}

\item
\texttt{void heap\_sort(int *a, int n)} — функция \textbf{пирамидальной сортировки}

\item
\texttt{void heapify(int *a, int n, int i)} — вспомогательная функция для \textbf{пирамидальной сортировки}, которая рекурсивно \textit{поднимает} $i$-й элемент кучи на его место. 
\end{itemize}

\textbf{Второй модуль} включает в себя функции:

\begin{itemize}
\item
\texttt{int rand\_int(void)} — функция генерирует рандомное число типа \texttt{int}.

\item
\texttt{int *generate\_array(int n, char mode, long long seed)} — функция генерирует в области \textit{динамической} памяти массив длины \texttt{n} определённого типа, в зависимости от значения параметра \texttt{mode}, который может принимать значения: \texttt{b}, \texttt{w} и \texttt{r}. Конфигурация \texttt{b} генерирует уже упорядоченный массив, \texttt{w} — обратно упорядоченный, \texttt{r} — рандомный массив чисел, для генерации которых используется функция \texttt{rand\_int}. Стоит отметить, что массив однозначно определен значением \texttt{seed}, которое задаётся в начале работы программы и используется для генерации одинаковых массивов. Данная функция \textbf{требует отдельного освобождения выделенной памяти}.

\item
\texttt{int is\_sorted(int *a, int n)} — \textit{логическая} функция проверяет упорядоченность массива

\item
\texttt{void test\_func(int, char, long long, void(int *, int))} — функция-оболочка для вызова функции сортировки: генерирует массив необходимой конфигурации; вызывает сортирующую функцию, подсчитывая при этом число операций \textit{сравнения} и \textit{перестановки}; дает отчёт по результатам сортировки и освобождает выделенную память.
\end{itemize}

Отдельно рассмотрим функцию \texttt{int main(void)}: она лишь вызывает \texttt{test\_func} с нужными параметрами.

\newpage

\section{Отладка программы, тестирование функций}

Написание программного кода происходило в среде разработки \texttt{CLion}, что позволило избежать ошибок компилляции и отладки программы. Тестрирование функций сортировки происходит автоматически при каждом выполнении.

\newpage

\section{Список цитируемой литературы}

Вспомогательная литература не была использована.

\newpage

\section{Анализ допущенных ошибок}

Ошибок допущено не было.


\end{document}
